---
phase: 03-web-visualization
plan: 04
type: execute
wave: 2
depends_on: ["03-02"]
files_modified:
  - src/web/static/app.js
  - src/web/static/websocket-client.js
autonomous: true

must_haves:
  truths:
    - "WebSocket connects to server with auto-reconnection"
    - "Game board updates when board state received"
    - "Metrics chart updates when episode data received"
    - "UI controls send commands to server"
    - "Status indicator reflects training state"
  artifacts:
    - path: "src/web/static/websocket-client.js"
      provides: "WebSocket client with reconnection logic"
      exports: ["WebSocketClient"]
    - path: "src/web/static/app.js"
      provides: "Complete application wiring"
  key_links:
    - from: "src/web/static/app.js"
      to: "src/web/static/websocket-client.js"
      via: "WebSocketClient instance"
      pattern: "WebSocketClient"
    - from: "src/web/static/app.js"
      to: "src/web/static/game-board.js"
      via: "GameBoard.render() on board message"
      pattern: "gameBoard\\.render"
    - from: "src/web/static/app.js"
      to: "src/web/static/metrics-chart.js"
      via: "MetricsChart.addDataPoint() on episode message"
      pattern: "metricsChart\\.addDataPoint"
---

<objective>
Complete frontend functionality: WebSocket client with auto-reconnection, and wire all UI components to real-time data.

Purpose: Connect the frontend (Plan 02) to the backend (Plans 01, 03) via WebSocket. The game board renders board state, the metrics chart shows episode data, and UI controls send commands.

Output: Fully functional frontend that displays live training visualization and accepts user input.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-web-visualization/03-RESEARCH.md

# Prior plan summaries
@.planning/phases/03-web-visualization/03-02-SUMMARY.md

# Frontend files to complete
@src/web/static/app.js
@src/web/static/game-board.js
@src/web/static/metrics-chart.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create WebSocket client with auto-reconnection</name>
  <files>src/web/static/websocket-client.js</files>
  <action>
Create `src/web/static/websocket-client.js`:

```javascript
/**
 * WebSocketClient - WebSocket wrapper with auto-reconnection and exponential backoff
 */
class WebSocketClient {
    /**
     * Create WebSocket client
     * @param {string} url - WebSocket URL (e.g., 'ws://localhost:8000/ws')
     * @param {function} onMessage - Callback for received messages
     * @param {function} onStatusChange - Callback for connection status changes
     */
    constructor(url, onMessage, onStatusChange) {
        this.url = url;
        this.onMessage = onMessage;
        this.onStatusChange = onStatusChange || (() => {});

        this.ws = null;
        this.reconnectDelay = 1000;  // Start with 1 second
        this.maxReconnectDelay = 30000;  // Max 30 seconds
        this.reconnectAttempts = 0;
        this.maxReconnectAttempts = 10;
        this.isIntentionallyClosed = false;

        this.connect();
    }

    /**
     * Establish WebSocket connection
     */
    connect() {
        if (this.isIntentionallyClosed) return;

        console.log(`WebSocket connecting to ${this.url}...`);
        this.onStatusChange('connecting');

        try {
            this.ws = new WebSocket(this.url);
        } catch (e) {
            console.error('WebSocket creation failed:', e);
            this.scheduleReconnect();
            return;
        }

        this.ws.onopen = () => {
            console.log('WebSocket connected');
            this.reconnectDelay = 1000;  // Reset delay on successful connect
            this.reconnectAttempts = 0;
            this.onStatusChange('connected');
        };

        this.ws.onmessage = (event) => {
            try {
                const data = JSON.parse(event.data);
                this.onMessage(data);
            } catch (e) {
                console.error('Failed to parse WebSocket message:', e);
            }
        };

        this.ws.onclose = (event) => {
            console.log(`WebSocket closed: ${event.code} ${event.reason}`);
            this.onStatusChange('disconnected');

            if (!this.isIntentionallyClosed) {
                this.scheduleReconnect();
            }
        };

        this.ws.onerror = (error) => {
            console.error('WebSocket error:', error);
            // onclose will be called after onerror
        };
    }

    /**
     * Schedule reconnection with exponential backoff
     */
    scheduleReconnect() {
        if (this.reconnectAttempts >= this.maxReconnectAttempts) {
            console.log('Max reconnect attempts reached');
            this.onStatusChange('failed');
            return;
        }

        this.reconnectAttempts++;
        console.log(`Reconnecting in ${this.reconnectDelay}ms (attempt ${this.reconnectAttempts})`);

        setTimeout(() => this.connect(), this.reconnectDelay);

        // Exponential backoff
        this.reconnectDelay = Math.min(
            this.reconnectDelay * 2,
            this.maxReconnectDelay
        );
    }

    /**
     * Send JSON message to server
     * @param {object} data - Data to send
     * @returns {boolean} - True if sent, false if not connected
     */
    send(data) {
        if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {
            console.warn('WebSocket not connected, cannot send');
            return false;
        }

        try {
            this.ws.send(JSON.stringify(data));
            return true;
        } catch (e) {
            console.error('Failed to send WebSocket message:', e);
            return false;
        }
    }

    /**
     * Close connection intentionally (no reconnect)
     */
    close() {
        this.isIntentionallyClosed = true;
        if (this.ws) {
            this.ws.close();
        }
    }

    /**
     * Check if connected
     * @returns {boolean}
     */
    isConnected() {
        return this.ws && this.ws.readyState === WebSocket.OPEN;
    }
}
```

Add script tag to index.html (before app.js):
```html
<script src="/static/websocket-client.js"></script>
```
  </action>
  <verify>
    ```bash
    grep -q "class WebSocketClient" src/web/static/websocket-client.js && echo "WebSocketClient OK"
    ```
  </verify>
  <done>
    WebSocketClient class created with auto-reconnection using exponential backoff.
  </done>
</task>

<task type="auto">
  <name>Task 2: Complete app.js with full WebSocket integration</name>
  <files>src/web/static/app.js</files>
  <action>
Replace `src/web/static/app.js` with complete implementation:

```javascript
/**
 * ML Tetris Trainer - Main Application
 * Coordinates WebSocket, game board, metrics chart, and UI controls
 */

// Global state
let wsClient = null;
let gameBoard = null;
let metricsChart = null;
let currentStatus = 'stopped';

/**
 * Initialize application when DOM is ready
 */
document.addEventListener('DOMContentLoaded', () => {
    console.log('ML Tetris Trainer initializing...');

    // Initialize game board
    gameBoard = new GameBoard('game-board');
    gameBoard.clear();

    // Initialize metrics chart
    metricsChart = new MetricsChart('metrics-chart');

    // Set up UI event handlers
    setupControls();

    // Connect WebSocket
    connectWebSocket();

    console.log('ML Tetris Trainer initialized');
});

/**
 * Connect to WebSocket server
 */
function connectWebSocket() {
    // Determine WebSocket URL (same host, /ws endpoint)
    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
    const wsUrl = `${protocol}//${window.location.host}/ws`;

    wsClient = new WebSocketClient(wsUrl, handleMessage, handleConnectionStatus);
}

/**
 * Handle incoming WebSocket messages
 * @param {object} data - Parsed JSON message
 */
function handleMessage(data) {
    switch (data.type) {
        case 'board':
            // Update game board visualization
            if (data.board) {
                gameBoard.render(data.board);
            }
            break;

        case 'metrics':
            // Update metrics display
            updateMetricsDisplay(data);
            break;

        case 'episode':
            // Episode completed - update chart
            if (data.episode !== undefined) {
                metricsChart.addDataPoint(
                    data.episode,
                    data.reward || 0,
                    data.lines || 0
                );
            }
            break;

        case 'status':
            // Training status changed
            if (data.status) {
                updateTrainingStatus(data.status);
            }
            if (data.message) {
                console.log(`Server: ${data.message}`);
            }
            break;

        case 'info':
            // Informational message
            console.log(`Info: ${data.message}`);
            break;

        case 'error':
            // Error from training
            console.error(`Training error: ${data.error}`);
            if (data.traceback) {
                console.error(data.traceback);
            }
            break;

        default:
            console.log('Unknown message type:', data);
    }
}

/**
 * Handle WebSocket connection status changes
 * @param {string} status - 'connecting', 'connected', 'disconnected', 'failed'
 */
function handleConnectionStatus(status) {
    const indicator = document.getElementById('status-indicator');
    const statusText = document.getElementById('status-text');

    switch (status) {
        case 'connecting':
            statusText.textContent = currentStatus + ' (connecting...)';
            break;

        case 'connected':
            statusText.textContent = currentStatus.charAt(0).toUpperCase() + currentStatus.slice(1);
            // Request current status from server
            wsClient.send({ command: 'status' });
            break;

        case 'disconnected':
            statusText.textContent = currentStatus + ' (reconnecting...)';
            break;

        case 'failed':
            statusText.textContent = 'Connection Failed';
            indicator.className = 'status stopped';
            break;
    }
}

/**
 * Update metrics display elements
 * @param {object} data - Metrics data
 */
function updateMetricsDisplay(data) {
    if (data.episode_count !== undefined) {
        document.getElementById('episode-count').textContent = data.episode_count;
    }
    if (data.current_score !== undefined) {
        document.getElementById('current-score').textContent = Math.round(data.current_score);
    }
    if (data.lines_cleared !== undefined) {
        document.getElementById('lines-cleared').textContent = data.lines_cleared;
    }
    if (data.timesteps !== undefined) {
        document.getElementById('timesteps').textContent = data.timesteps.toLocaleString();
    }
    if (data.avg_reward !== undefined) {
        document.getElementById('avg-reward').textContent = data.avg_reward.toFixed(2);
    }
    if (data.best_lines !== undefined) {
        document.getElementById('best-lines').textContent = data.best_lines;
    }
}

/**
 * Update training status indicator and controls
 * @param {string} status - 'stopped', 'running', 'stopping'
 */
function updateTrainingStatus(status) {
    currentStatus = status;

    const indicator = document.getElementById('status-indicator');
    const statusText = document.getElementById('status-text');
    const btnStart = document.getElementById('btn-start');
    const btnStop = document.getElementById('btn-stop');
    const configInputs = document.querySelectorAll('.config-item input');

    // Update status indicator
    indicator.className = 'status ' + (status === 'stopping' ? 'paused' : status);
    statusText.textContent = status.charAt(0).toUpperCase() + status.slice(1);

    // Update button states
    btnStart.disabled = (status === 'running' || status === 'stopping');
    btnStop.disabled = (status !== 'running');

    // Disable config inputs while training
    configInputs.forEach(input => {
        input.disabled = (status === 'running' || status === 'stopping');
    });

    // Clear board and chart when stopping
    if (status === 'stopped') {
        // Keep last state visible, don't clear
    }
}

/**
 * Set up UI control event handlers
 */
function setupControls() {
    const btnStart = document.getElementById('btn-start');
    const btnStop = document.getElementById('btn-stop');

    btnStart.addEventListener('click', () => {
        // Get config values from inputs
        const targetLines = parseInt(document.getElementById('target-lines').value) || null;
        const maxTimesteps = parseInt(document.getElementById('max-timesteps').value) || 100000;

        // Send start command with config
        const sent = wsClient.send({
            command: 'start',
            config: {
                target_lines: targetLines,
                max_timesteps: maxTimesteps,
            }
        });

        if (sent) {
            console.log('Start command sent');
            updateTrainingStatus('running');
            metricsChart.clear();  // Clear chart for new training session
        } else {
            console.error('Failed to send start command - not connected');
        }
    });

    btnStop.addEventListener('click', () => {
        const sent = wsClient.send({ command: 'stop' });

        if (sent) {
            console.log('Stop command sent');
            updateTrainingStatus('stopping');
        } else {
            console.error('Failed to send stop command - not connected');
        }
    });
}

// Export for debugging
window.app = {
    gameBoard: () => gameBoard,
    metricsChart: () => metricsChart,
    wsClient: () => wsClient,
    status: () => currentStatus,
};
```
  </action>
  <verify>
    ```bash
    grep -q "handleMessage" src/web/static/app.js && grep -q "WebSocketClient" src/web/static/app.js && echo "app.js OK"
    ```
  </verify>
  <done>
    app.js fully wired: WebSocket connects, board updates on 'board' messages, chart updates on 'episode' messages, buttons send commands.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update index.html to include websocket-client.js and verify load order</name>
  <files>src/web/templates/index.html</files>
  <action>
Update the script tags in `src/web/templates/index.html` to include websocket-client.js in the correct order:

```html
    <!-- Load scripts in order: dependencies first, then app -->
    <script src="/static/game-board.js"></script>
    <script src="/static/metrics-chart.js"></script>
    <script src="/static/websocket-client.js"></script>
    <script src="/static/app.js"></script>
</body>
</html>
```

The order matters:
1. game-board.js - GameBoard class (no dependencies)
2. metrics-chart.js - MetricsChart class (depends on Chart.js from CDN in head)
3. websocket-client.js - WebSocketClient class (no dependencies)
4. app.js - Uses all of the above

Verify by opening in browser:
```bash
# Start server
python -m uvicorn src.web.server:app --host 127.0.0.1 --port 8000 &
sleep 2

# Open in browser (or curl to verify server is up)
curl -s http://127.0.0.1:8000/ | grep -q "ML Tetris" && echo "Page loads OK"

# Kill server
pkill -f "uvicorn src.web.server"
```
  </action>
  <verify>
    ```bash
    grep -q "websocket-client.js" src/web/templates/index.html && echo "Script tag added"
    ```
  </verify>
  <done>
    index.html has correct script load order, all JavaScript modules load without errors.
  </done>
</task>

</tasks>

<verification>
All tasks complete when:
1. WebSocketClient connects with auto-reconnection
2. GameBoard.render() called when 'board' message received
3. MetricsChart.addDataPoint() called when 'episode' message received
4. Start/Stop buttons send commands via WebSocket
5. Status indicator updates based on training state
6. No console errors when loading page
</verification>

<success_criteria>
- VIS-02: Game board updates with live Tetris state
- VIS-03: Status indicator shows running/paused/stopped
- VIS-04: Split view with synchronized game and metrics
- TRAIN-02: Start button sends start command
- TRAIN-03: Stop button sends stop command
- TRAIN-05: Metrics display updates in real-time
- TRAIN-06: Chart updates when episodes complete
</success_criteria>

<output>
After completion, create `.planning/phases/03-web-visualization/03-04-SUMMARY.md`
</output>
