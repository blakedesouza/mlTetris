---
phase: 03-web-visualization
plan: 05
type: execute
wave: 3
depends_on: ["03-03", "03-04"]
files_modified:
  - src/web/server.py
autonomous: false

must_haves:
  truths:
    - "User can open browser and see Tetris game board"
    - "User can start training from web UI"
    - "User can stop training from web UI"
    - "Dashboard shows live metrics during training"
    - "Real-time chart updates as episodes complete"
    - "Training status indicator reflects actual state"
  artifacts:
    - path: "src/web/server.py"
      provides: "Complete server with WebSocket command handling"
  key_links:
    - from: "src/web/server.py"
      to: "src/web/training_manager.py"
      via: "start_training/stop_training calls from WebSocket"
      pattern: "training_manager\\.(start|stop)_training"
    - from: "WebSocket /ws"
      to: "Frontend app.js"
      via: "JSON messages"
      pattern: "websocket\\.send_json"
---

<objective>
Complete server-side WebSocket command handling and verify full end-to-end integration.

Purpose: Wire the server to handle WebSocket commands (start/stop) and complete the full data flow: UI -> WebSocket -> TrainingManager -> Training Process -> Queue -> WebSocket -> UI.

Output: Fully functional web dashboard where users can start/stop training and watch live visualization.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-web-visualization/03-RESEARCH.md

# Prior plan summaries
@.planning/phases/03-web-visualization/03-01-SUMMARY.md
@.planning/phases/03-web-visualization/03-02-SUMMARY.md
@.planning/phases/03-web-visualization/03-03-SUMMARY.md
@.planning/phases/03-web-visualization/03-04-SUMMARY.md

# Server to complete
@src/web/server.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Complete WebSocket command handling in server.py</name>
  <files>src/web/server.py</files>
  <action>
Update `src/web/server.py` to handle WebSocket commands properly:

The WebSocket endpoint should:
1. Receive JSON messages with `command` field
2. Handle "start" command: Extract config, call training_manager.start_training()
3. Handle "stop" command: Call training_manager.stop_training()
4. Handle "status" command: Send current training status
5. Send confirmation/error responses back to client

Update the WebSocket endpoint:

```python
@app.websocket("/ws")
async def websocket_endpoint(websocket: WebSocket):
    """WebSocket endpoint for real-time communication."""
    await connection_manager.connect(websocket)
    try:
        while True:
            # Receive command from client
            data = await websocket.receive_json()
            command = data.get("command")

            if command == "start":
                # Extract config from message
                config = data.get("config", {})
                config_dict = {
                    "target_lines": config.get("target_lines"),
                    "max_timesteps": config.get("max_timesteps", 100000),
                    "checkpoint_dir": "./checkpoints",
                    "checkpoint_freq": 10000,
                }

                success = training_manager.start_training(config_dict)
                if success:
                    await websocket.send_json({
                        "type": "status",
                        "status": "running",
                        "message": "Training started",
                    })
                else:
                    await websocket.send_json({
                        "type": "error",
                        "error": "Training already running",
                    })

            elif command == "stop":
                training_manager.stop_training()
                await websocket.send_json({
                    "type": "status",
                    "status": "stopped",
                    "message": "Training stopped",
                })

            elif command == "status":
                # Send current status
                status = "running" if training_manager.is_running() else "stopped"
                await websocket.send_json({
                    "type": "status",
                    "status": status,
                })

            else:
                await websocket.send_json({
                    "type": "error",
                    "error": f"Unknown command: {command}",
                })

    except WebSocketDisconnect:
        connection_manager.disconnect(websocket)
```

Also update the REST endpoints to match:

```python
@app.post("/api/training/start")
async def start_training(config: dict = {}):
    """Start training via REST API."""
    config_dict = {
        "target_lines": config.get("target_lines"),
        "max_timesteps": config.get("max_timesteps", 100000),
        "checkpoint_dir": "./checkpoints",
        "checkpoint_freq": 10000,
    }
    success = training_manager.start_training(config_dict)
    if success:
        return {"status": "running", "message": "Training started"}
    return {"status": "error", "message": "Training already running"}

@app.post("/api/training/stop")
async def stop_training():
    """Stop training via REST API."""
    training_manager.stop_training()
    return {"status": "stopped", "message": "Training stopped"}

@app.get("/api/status")
async def get_status():
    """Get current training status."""
    return {
        "status": "running" if training_manager.is_running() else "stopped",
    }
```

Make sure imports are complete at the top of the file.
  </action>
  <verify>
    ```bash
    python -c "from src.web.server import app; print('Server OK')"
    ```
  </verify>
  <done>
    server.py handles WebSocket commands (start/stop/status) and coordinates with TrainingManager.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integration test - full data flow</name>
  <files>None (verification only)</files>
  <action>
Run a quick integration test to verify the full data flow works:

```bash
# Start server in background
python -m uvicorn src.web.server:app --host 127.0.0.1 --port 8000 &
SERVER_PID=$!
sleep 3

# Test REST endpoints
echo "Testing REST API..."
curl -s http://127.0.0.1:8000/api/status
echo ""

# Test starting training via REST
curl -s -X POST http://127.0.0.1:8000/api/training/start \
  -H "Content-Type: application/json" \
  -d '{"max_timesteps": 1000}'
echo ""

# Wait for some training
sleep 5

# Check status
curl -s http://127.0.0.1:8000/api/status
echo ""

# Stop training
curl -s -X POST http://127.0.0.1:8000/api/training/stop
echo ""

# Kill server
kill $SERVER_PID 2>/dev/null || true
echo "Integration test complete"
```

Also verify the page loads correctly:
```bash
python -m uvicorn src.web.server:app --host 127.0.0.1 --port 8000 &
SERVER_PID=$!
sleep 2

curl -s http://127.0.0.1:8000/ | head -20

kill $SERVER_PID 2>/dev/null || true
```
  </action>
  <verify>
    ```bash
    # Quick syntax check
    python -c "from src.web.server import app, training_manager, connection_manager; print('All imports OK')"
    ```
  </verify>
  <done>
    REST API endpoints work. Server starts training, status updates, training stops.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Human verification of complete web dashboard</name>
  <what-built>
Complete web visualization dashboard with:
- Split view: game board (left) + metrics/controls (right)
- Real-time Tetris board rendering via Canvas
- Real-time metrics chart via Chart.js
- Start/Stop training controls
- Training status indicator
- WebSocket communication with auto-reconnection
  </what-built>
  <how-to-verify>
1. Start the server:
   ```
   python -m uvicorn src.web.server:app --host 127.0.0.1 --port 8000
   ```

2. Open browser to http://127.0.0.1:8000

3. Verify initial state:
   - Page loads with split view layout
   - Status shows "Stopped" with red indicator
   - Start button enabled, Stop button disabled
   - Empty game board with grid visible
   - Empty metrics chart

4. Click "Start Training" button:
   - Status changes to "Running" with green indicator
   - Stop button becomes enabled, Start disabled
   - Game board starts showing Tetris pieces moving
   - Metrics update: episode count, score, lines cleared
   - Chart begins plotting episode rewards and lines

5. Let it run for 30-60 seconds, observe:
   - Board updates smoothly (not jerky)
   - Metrics increment as episodes complete
   - Chart shows multiple data points

6. Click "Stop Training" button:
   - Status changes to "Stopped"
   - Training process terminates
   - Last board state and metrics remain visible

7. Refresh page:
   - WebSocket reconnects automatically
   - Status reflects server state (stopped)

8. Test reconnection:
   - Start training
   - Disconnect network briefly (if possible) or close browser tab
   - Reopen - should reconnect and show current state
  </how-to-verify>
  <resume-signal>Type "approved" if dashboard works correctly, or describe any issues</resume-signal>
</task>

</tasks>

<verification>
Phase 3 complete when:
1. Server handles WebSocket commands correctly
2. Training starts/stops from web UI
3. Board state displays in real-time
4. Metrics chart updates with episode data
5. Status indicator reflects training state
6. Human verification confirms usability
</verification>

<success_criteria>
Phase 3 Success Criteria from ROADMAP.md:
1. [x] User can open browser and see the Tetris game board with current AI play
2. [x] User can start new training session from web UI
3. [x] User can stop training session from web UI
4. [x] Dashboard shows live metrics (episode count, current score, lines cleared)
5. [x] Real-time chart updates showing reward/score progression during training
6. [x] Split view displays game board and metrics side by side
7. [x] Training status indicator shows running/paused/stopped state

Requirements covered:
- VIS-01: Web-based interface accessible via browser
- VIS-02: Live game board showing current Tetris state
- VIS-03: Training status indicator (running/paused/stopped)
- VIS-04: Split view layout (game board + metrics side by side)
- TRAIN-02: Start training from web UI
- TRAIN-03: Stop training from web UI
- TRAIN-05: Progress display (episode count, current score, lines cleared)
- TRAIN-06: Real-time reward/score chart updating during training
- TRAIN-08: Visual mode for watching AI play in real-time
</success_criteria>

<output>
After completion, create `.planning/phases/03-web-visualization/03-05-SUMMARY.md`
</output>
