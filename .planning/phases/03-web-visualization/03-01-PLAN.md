---
phase: 03-web-visualization
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/web/__init__.py
  - src/web/server.py
  - src/web/training_manager.py
  - src/web/connection_manager.py
autonomous: true

must_haves:
  truths:
    - "FastAPI server starts and serves routes"
    - "WebSocket endpoint accepts connections"
    - "Training can be started/stopped via TrainingManager"
    - "Process isolation prevents blocking the event loop"
  artifacts:
    - path: "src/web/__init__.py"
      provides: "Web module package marker"
    - path: "src/web/server.py"
      provides: "FastAPI app with routes and WebSocket endpoint"
      exports: ["app", "startup_event"]
    - path: "src/web/training_manager.py"
      provides: "Process-based training management with Queue communication"
      exports: ["TrainingManager"]
    - path: "src/web/connection_manager.py"
      provides: "WebSocket connection tracking and broadcasting"
      exports: ["ConnectionManager"]
  key_links:
    - from: "src/web/server.py"
      to: "src/web/training_manager.py"
      via: "TrainingManager instance"
      pattern: "training_manager\\.(start|stop)"
    - from: "src/web/server.py"
      to: "src/web/connection_manager.py"
      via: "ConnectionManager for WebSocket broadcast"
      pattern: "connection_manager\\.broadcast"
---

<objective>
Create FastAPI web server with WebSocket support and process-based training management.

Purpose: Establish the backend infrastructure for real-time web visualization. Training runs in a separate process to avoid blocking the async event loop, with Queue-based communication for metrics.

Output: Working FastAPI server that can start/stop training sessions and broadcast updates via WebSocket.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-web-visualization/03-RESEARCH.md

# Existing training infrastructure to integrate with
@src/training/train.py
@src/training/agent.py
@src/training/config.py
@src/training/callbacks.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create web module with ConnectionManager and TrainingManager</name>
  <files>
    src/web/__init__.py
    src/web/connection_manager.py
    src/web/training_manager.py
  </files>
  <action>
Create the web module structure:

1. `src/web/__init__.py` - Package marker with exports:
   ```python
   from .connection_manager import ConnectionManager
   from .training_manager import TrainingManager
   ```

2. `src/web/connection_manager.py` - WebSocket connection tracking:
   - `ConnectionManager` class with:
     - `active_connections: List[WebSocket]`
     - `async connect(websocket)` - Accept and track connection
     - `disconnect(websocket)` - Remove from tracking
     - `async broadcast(message: dict)` - Send JSON to all connected clients
     - `async send_to(websocket, message: dict)` - Send to specific client
   - Handle disconnected clients gracefully in broadcast (catch exceptions, don't crash)

3. `src/web/training_manager.py` - Process-based training management:
   - Use `multiprocessing.Process` and `multiprocessing.Queue` for isolation
   - `TrainingManager` class with:
     - `metrics_queue: Queue` - Training to server (metrics, board state)
     - `command_queue: Queue` - Server to training (stop command)
     - `process: Optional[Process]` - Training process handle
     - `status: str` - "stopped", "running", "stopping"
     - `start_training(config_dict: dict) -> bool` - Start training in subprocess
     - `stop_training() -> None` - Send stop command, wait with timeout, terminate if needed
     - `is_running() -> bool` - Check if process is alive
     - `@staticmethod _training_worker(config_dict, metrics_queue, command_queue)` - Worker function

   The `_training_worker` should:
   - Import training modules inside function (avoid pickle issues)
   - Create environment and agent from config
   - NOT actually implement training loop yet (Plan 03 does that)
   - Just stub with pass for now - the worker signature matters

Use research patterns from 03-RESEARCH.md (Pattern 1: Training Process Isolation).
  </action>
  <verify>
    ```bash
    python -c "from src.web import ConnectionManager, TrainingManager; print('Imports OK')"
    ```
  </verify>
  <done>
    ConnectionManager and TrainingManager classes importable with correct method signatures.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create FastAPI server with routes and WebSocket endpoint</name>
  <files>src/web/server.py</files>
  <action>
Create `src/web/server.py` with FastAPI application:

1. Import dependencies:
   ```python
   from fastapi import FastAPI, WebSocket, WebSocketDisconnect, Request
   from fastapi.staticfiles import StaticFiles
   from fastapi.templating import Jinja2Templates
   from fastapi.responses import HTMLResponse
   from fastapi.middleware.cors import CORSMiddleware
   import asyncio
   ```

2. Create FastAPI app with CORS middleware:
   ```python
   app = FastAPI(title="ML Tetris Trainer")
   app.add_middleware(
       CORSMiddleware,
       allow_origins=["*"],  # Allow all for local dev
       allow_methods=["*"],
       allow_headers=["*"],
   )
   ```

3. Mount static files and templates:
   - `app.mount("/static", StaticFiles(directory="src/web/static"), name="static")`
   - `templates = Jinja2Templates(directory="src/web/templates")`
   - Note: These directories don't exist yet (Plan 02 creates them), but server.py should be ready

4. Create module-level instances:
   ```python
   connection_manager = ConnectionManager()
   training_manager = TrainingManager()
   ```

5. Routes:
   - `GET /` - Serve index.html template (HTMLResponse)
   - `GET /api/status` - Return training status as JSON
   - `POST /api/training/start` - Start training (accept optional config JSON body)
   - `POST /api/training/stop` - Stop training

6. WebSocket endpoint at `/ws`:
   - Accept connection via connection_manager
   - Loop receiving JSON messages
   - Handle commands: {"command": "start"}, {"command": "stop"}
   - Catch WebSocketDisconnect and clean up

7. Background task for metrics polling:
   ```python
   async def poll_metrics():
       while True:
           # Check metrics_queue (non-blocking)
           while not training_manager.metrics_queue.empty():
               try:
                   metrics = training_manager.metrics_queue.get_nowait()
                   await connection_manager.broadcast(metrics)
               except:
                   break
           await asyncio.sleep(0.1)  # 100ms poll interval
   ```

8. Startup event to launch metrics polling:
   ```python
   @app.on_event("startup")
   async def startup_event():
       asyncio.create_task(poll_metrics())
   ```

9. Shutdown event for cleanup:
   ```python
   @app.on_event("shutdown")
   async def shutdown_event():
       training_manager.stop_training()
   ```

Use research patterns from 03-RESEARCH.md (Pattern 2: WebSocket Connection Manager).
  </action>
  <verify>
    ```bash
    python -c "from src.web.server import app; print(f'Routes: {[r.path for r in app.routes]}')"
    ```
  </verify>
  <done>
    FastAPI app importable with routes: /, /api/status, /api/training/start, /api/training/stop, /ws
  </done>
</task>

<task type="auto">
  <name>Task 3: Install web dependencies and verify server starts</name>
  <files>pyproject.toml</files>
  <action>
1. Add web dependencies to pyproject.toml:
   ```toml
   # In [project.optional-dependencies] or main dependencies
   # Add to existing dependencies list:
   "fastapi>=0.116.0",
   "uvicorn[standard]>=0.35.0",
   "jinja2>=3.1.0",
   "aiofiles>=24.1.0",
   ```

2. Install dependencies:
   ```bash
   pip install -e ".[dev]"
   ```
   Or if using main dependencies:
   ```bash
   pip install -e .
   ```

3. Create minimal placeholder directories so server can start:
   ```bash
   mkdir -p src/web/static src/web/templates
   touch src/web/static/.gitkeep
   ```

4. Create minimal index.html placeholder:
   ```html
   <!-- src/web/templates/index.html -->
   <!DOCTYPE html>
   <html>
   <head><title>ML Tetris</title></head>
   <body><h1>ML Tetris Trainer</h1><p>Loading...</p></body>
   </html>
   ```

5. Verify server starts:
   ```bash
   timeout 5 python -m uvicorn src.web.server:app --host 127.0.0.1 --port 8000 || true
   ```
   (Server should start, timeout kills it after 5 seconds)

6. Run existing tests to ensure no regressions:
   ```bash
   python -m pytest tests/ -x -q
   ```
  </action>
  <verify>
    ```bash
    python -c "import uvicorn; from src.web.server import app; print('Server ready')"
    curl -s http://127.0.0.1:8000/api/status 2>/dev/null || echo "Server not running (expected in verify)"
    ```
  </verify>
  <done>
    Web dependencies installed, placeholder directories exist, server imports without error, existing tests pass.
  </done>
</task>

</tasks>

<verification>
All tasks complete when:
1. `from src.web import ConnectionManager, TrainingManager` succeeds
2. `from src.web.server import app` succeeds
3. Server can be started with `uvicorn src.web.server:app`
4. Existing tests pass (no regressions)
</verification>

<success_criteria>
- FastAPI server with WebSocket endpoint created
- TrainingManager with process isolation implemented
- ConnectionManager for WebSocket broadcasting implemented
- Web dependencies added to pyproject.toml
- Server starts without errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-web-visualization/03-01-SUMMARY.md`
</output>
