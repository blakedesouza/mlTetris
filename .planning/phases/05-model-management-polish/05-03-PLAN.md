---
phase: 05-model-management-polish
plan: 03
type: execute
wave: 3
depends_on: ["05-01", "05-02"]
files_modified:
  - src/web/templates/index.html
  - src/web/static/styles.css
  - src/web/static/model-manager.js
  - src/web/static/app.js
autonomous: false

must_haves:
  truths:
    - "User sees leaderboard table with all saved models"
    - "User can save current best model to a named slot"
    - "User can delete a saved model slot"
    - "User can export a model to downloadable file"
    - "User can start demo mode for any saved model"
    - "User can stop demo mode"
    - "Leaderboard refreshes after save/delete operations"
  artifacts:
    - path: "src/web/templates/index.html"
      provides: "Model management UI section"
      contains: "model-list"
    - path: "src/web/static/model-manager.js"
      provides: "Model management JavaScript module"
      exports: ["ModelManager"]
    - path: "src/web/static/styles.css"
      provides: "Styling for model table and buttons"
      contains: ".model-table"
  key_links:
    - from: "src/web/static/model-manager.js"
      to: "/api/models"
      via: "fetch API calls"
      pattern: "fetch.*api/models"
    - from: "src/web/static/app.js"
      to: "src/web/static/model-manager.js"
      via: "ModelManager instantiation"
      pattern: "new ModelManager\\("
---

<objective>
Create frontend UI for model management including leaderboard table, save/delete/export operations, and demo mode controls.

Purpose: Enable users to manage and showcase trained models through the web interface.
Output: Model management section in dashboard with leaderboard, action buttons, and demo controls.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-model-management-polish/05-RESEARCH.md
@.planning/phases/05-model-management-polish/05-01-SUMMARY.md
@.planning/phases/05-model-management-polish/05-02-SUMMARY.md

# Existing infrastructure
@src/web/templates/index.html
@src/web/static/styles.css
@src/web/static/app.js
@src/web/static/websocket-client.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create model management UI section in HTML and CSS</name>
  <files>src/web/templates/index.html, src/web/static/styles.css</files>
  <action>
1. Add model management section to src/web/templates/index.html.

Insert after the config-section div (before closing metrics-panel section):

```html
<div class="model-section">
    <h3>Saved Models</h3>

    <div class="model-actions">
        <button id="btn-save-model" class="btn btn-secondary">Save Current Model</button>
        <button id="btn-refresh-models" class="btn btn-secondary">Refresh</button>
    </div>

    <div class="model-table-container">
        <table class="model-table">
            <thead>
                <tr>
                    <th class="sortable" data-sort="name">Name</th>
                    <th class="sortable" data-sort="lines">Best Lines</th>
                    <th class="sortable" data-sort="timesteps">Timesteps</th>
                    <th>Actions</th>
                </tr>
            </thead>
            <tbody id="model-list">
                <!-- Populated by JavaScript -->
                <tr class="empty-row">
                    <td colspan="4">No saved models yet</td>
                </tr>
            </tbody>
        </table>
    </div>
</div>
```

2. Add script include for model-manager.js before app.js:

```html
<script src="/static/model-manager.js"></script>
```

3. Add CSS styles for model section to src/web/static/styles.css:

```css
/* Model Management Section */
.model-section {
    margin-top: 1.5rem;
    padding-top: 1rem;
    border-top: 1px solid var(--border-color);
}

.model-section h3 {
    margin-bottom: 1rem;
    color: var(--text-color);
}

.model-actions {
    display: flex;
    gap: 0.5rem;
    margin-bottom: 1rem;
}

.model-table-container {
    max-height: 300px;
    overflow-y: auto;
    border: 1px solid var(--border-color);
    border-radius: 4px;
}

.model-table {
    width: 100%;
    border-collapse: collapse;
    font-size: 0.9rem;
}

.model-table th,
.model-table td {
    padding: 0.5rem 0.75rem;
    text-align: left;
    border-bottom: 1px solid var(--border-color);
}

.model-table th {
    background-color: var(--header-bg);
    font-weight: 600;
    position: sticky;
    top: 0;
}

.model-table th.sortable {
    cursor: pointer;
}

.model-table th.sortable:hover {
    background-color: var(--hover-bg);
}

.model-table th.sortable::after {
    content: ' \2195';
    opacity: 0.5;
}

.model-table tbody tr:hover {
    background-color: var(--hover-bg);
}

.model-table .empty-row td {
    text-align: center;
    color: var(--text-muted);
    padding: 2rem;
}

.model-table .action-buttons {
    display: flex;
    gap: 0.25rem;
}

.model-table .btn-action {
    padding: 0.25rem 0.5rem;
    font-size: 0.8rem;
    border: none;
    border-radius: 3px;
    cursor: pointer;
}

.btn-demo {
    background-color: var(--success-color);
    color: white;
}

.btn-demo:hover {
    background-color: var(--success-hover);
}

.btn-demo.active {
    background-color: var(--warning-color);
}

.btn-export {
    background-color: var(--info-color);
    color: white;
}

.btn-export:hover {
    background-color: var(--info-hover);
}

.btn-delete {
    background-color: var(--danger-color);
    color: white;
}

.btn-delete:hover {
    background-color: var(--danger-hover);
}

.btn-secondary {
    background-color: var(--secondary-color);
    color: white;
    border: none;
    padding: 0.5rem 1rem;
    border-radius: 4px;
    cursor: pointer;
}

.btn-secondary:hover {
    background-color: var(--secondary-hover);
}

/* Add CSS variables if not present */
:root {
    --success-color: #28a745;
    --success-hover: #218838;
    --info-color: #17a2b8;
    --info-hover: #138496;
    --danger-color: #dc3545;
    --danger-hover: #c82333;
    --warning-color: #ffc107;
    --secondary-color: #6c757d;
    --secondary-hover: #5a6268;
    --hover-bg: rgba(0, 0, 0, 0.05);
    --header-bg: #f8f9fa;
    --text-muted: #6c757d;
}
```

Note: Check if CSS variables already exist in styles.css - if so, only add missing ones.
  </action>
  <verify>
Verify HTML structure is correct:
```bash
grep -c "model-section" src/web/templates/index.html
grep -c "model-table" src/web/static/styles.css
```
Both should return 1 or more.
  </verify>
  <done>Model management section exists in HTML with table structure. CSS styles for table, buttons, and hover states complete.</done>
</task>

<task type="auto">
  <name>Task 2: Create ModelManager JavaScript module</name>
  <files>src/web/static/model-manager.js</files>
  <action>
Create src/web/static/model-manager.js with ModelManager class:

```javascript
/**
 * ModelManager - Handles model slot operations
 * Provides CRUD operations for saved models and demo mode control
 */
class ModelManager {
    constructor(wsClient) {
        this.wsClient = wsClient;
        this.models = [];
        this.currentDemo = null;  // Currently playing demo slot name
        this.sortColumn = 'name';
        this.sortAsc = true;

        this.setupEventListeners();
        this.loadModels();
    }

    /**
     * Set up event listeners for model management UI
     */
    setupEventListeners() {
        // Save model button
        document.getElementById('btn-save-model').addEventListener('click', () => {
            this.saveCurrentModel();
        });

        // Refresh button
        document.getElementById('btn-refresh-models').addEventListener('click', () => {
            this.loadModels();
        });

        // Table header sorting
        document.querySelectorAll('.model-table th.sortable').forEach(th => {
            th.addEventListener('click', () => {
                const column = th.dataset.sort;
                if (this.sortColumn === column) {
                    this.sortAsc = !this.sortAsc;
                } else {
                    this.sortColumn = column;
                    this.sortAsc = true;
                }
                this.renderTable();
            });
        });
    }

    /**
     * Load models from server
     */
    async loadModels() {
        try {
            const response = await fetch('/api/models');
            if (response.ok) {
                this.models = await response.json();
                this.renderTable();
            } else {
                console.error('Failed to load models:', response.status);
            }
        } catch (error) {
            console.error('Error loading models:', error);
        }
    }

    /**
     * Render model table
     */
    renderTable() {
        const tbody = document.getElementById('model-list');

        if (this.models.length === 0) {
            tbody.innerHTML = '<tr class="empty-row"><td colspan="4">No saved models yet</td></tr>';
            return;
        }

        // Sort models
        const sorted = [...this.models].sort((a, b) => {
            let valA, valB;
            switch (this.sortColumn) {
                case 'name':
                    valA = a.name || '';
                    valB = b.name || '';
                    return this.sortAsc ? valA.localeCompare(valB) : valB.localeCompare(valA);
                case 'lines':
                    valA = a.best_lines || a.config?.target_lines || 0;
                    valB = b.best_lines || b.config?.target_lines || 0;
                    break;
                case 'timesteps':
                    valA = a.total_timesteps_trained || a.num_timesteps || 0;
                    valB = b.total_timesteps_trained || b.num_timesteps || 0;
                    break;
                default:
                    valA = 0;
                    valB = 0;
            }
            return this.sortAsc ? valA - valB : valB - valA;
        });

        // Build table rows
        tbody.innerHTML = sorted.map(model => {
            const name = model.name || 'unknown';
            const lines = model.best_lines || model.config?.target_lines || '-';
            const timesteps = (model.total_timesteps_trained || model.num_timesteps || 0).toLocaleString();
            const isDemo = this.currentDemo === name;

            return `
                <tr data-slot="${name}">
                    <td>${this.escapeHtml(name)}</td>
                    <td>${lines}</td>
                    <td>${timesteps}</td>
                    <td class="action-buttons">
                        <button class="btn-action btn-demo ${isDemo ? 'active' : ''}"
                                onclick="modelManager.toggleDemo('${this.escapeHtml(name)}')"
                                title="${isDemo ? 'Stop Demo' : 'Watch Demo'}">
                            ${isDemo ? 'Stop' : 'Demo'}
                        </button>
                        <button class="btn-action btn-export"
                                onclick="modelManager.exportModel('${this.escapeHtml(name)}')"
                                title="Export model file">
                            Export
                        </button>
                        <button class="btn-action btn-delete"
                                onclick="modelManager.deleteModel('${this.escapeHtml(name)}')"
                                title="Delete model">
                            Delete
                        </button>
                    </td>
                </tr>
            `;
        }).join('');
    }

    /**
     * Save current model to a named slot
     */
    async saveCurrentModel() {
        const slotName = prompt('Enter a name for this model slot:', `model_${Date.now()}`);
        if (!slotName) return;

        // Validate slot name (alphanumeric, underscore, hyphen)
        if (!/^[a-zA-Z0-9_-]+$/.test(slotName)) {
            alert('Invalid name. Use only letters, numbers, underscores, and hyphens.');
            return;
        }

        try {
            const response = await fetch('/api/models/save', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ source: 'best', slot_name: slotName })
            });

            const data = await response.json();
            if (data.success) {
                console.log(`Model saved to slot: ${slotName}`);
                this.loadModels();  // Refresh table
            } else {
                alert(`Failed to save model: ${data.error || 'Unknown error'}`);
            }
        } catch (error) {
            console.error('Error saving model:', error);
            alert('Error saving model. Check console for details.');
        }
    }

    /**
     * Delete a model slot
     */
    async deleteModel(slotName) {
        if (!confirm(`Delete model "${slotName}"? This cannot be undone.`)) {
            return;
        }

        try {
            const response = await fetch(`/api/models/${encodeURIComponent(slotName)}`, {
                method: 'DELETE'
            });

            const data = await response.json();
            if (data.success) {
                console.log(`Model deleted: ${slotName}`);
                // Stop demo if deleting current demo model
                if (this.currentDemo === slotName) {
                    this.stopDemo();
                }
                this.loadModels();  // Refresh table
            } else {
                alert(`Failed to delete model: ${data.error || 'Unknown error'}`);
            }
        } catch (error) {
            console.error('Error deleting model:', error);
            alert('Error deleting model. Check console for details.');
        }
    }

    /**
     * Export model to downloadable file
     */
    async exportModel(slotName) {
        const filename = `${slotName}.zip`;

        try {
            const response = await fetch('/api/models/export', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ slot_name: slotName, filename: filename })
            });

            const data = await response.json();
            if (data.success) {
                // Create download link
                // Note: The file is saved server-side to exports/
                // For actual download, would need a download endpoint
                alert(`Model exported to: ${data.path}\n\nFile saved on server. Manual retrieval required.`);
            } else {
                alert(`Failed to export model: ${data.error || 'Unknown error'}`);
            }
        } catch (error) {
            console.error('Error exporting model:', error);
            alert('Error exporting model. Check console for details.');
        }
    }

    /**
     * Toggle demo mode for a model
     */
    toggleDemo(slotName) {
        if (this.currentDemo === slotName) {
            this.stopDemo();
        } else {
            this.startDemo(slotName);
        }
    }

    /**
     * Start demo mode for a model
     */
    startDemo(slotName) {
        // Stop any existing demo first
        if (this.currentDemo) {
            this.stopDemo();
        }

        // Send via WebSocket
        const sent = this.wsClient.send({
            command: 'demo_start',
            slot_name: slotName
        });

        if (sent) {
            this.currentDemo = slotName;
            this.renderTable();  // Update button state
            console.log(`Demo started: ${slotName}`);
        } else {
            alert('Cannot start demo - not connected to server');
        }
    }

    /**
     * Stop demo mode
     */
    stopDemo() {
        const sent = this.wsClient.send({ command: 'demo_stop' });

        if (sent) {
            this.currentDemo = null;
            this.renderTable();  // Update button state
            console.log('Demo stopped');
        }
    }

    /**
     * Handle status updates from server
     */
    handleStatus(data) {
        if (data.status === 'stopped' && this.currentDemo) {
            this.currentDemo = null;
            this.renderTable();
        } else if (data.status === 'demo_running') {
            // Demo is running - UI should already be updated
        }
    }

    /**
     * Escape HTML to prevent XSS
     */
    escapeHtml(str) {
        const div = document.createElement('div');
        div.textContent = str;
        return div.innerHTML;
    }
}

// Global instance - will be created in app.js
let modelManager = null;
```
  </action>
  <verify>
```bash
test -f src/web/static/model-manager.js && echo "model-manager.js exists"
grep -c "class ModelManager" src/web/static/model-manager.js
```
  </verify>
  <done>ModelManager class exists with loadModels, saveCurrentModel, deleteModel, exportModel, startDemo, stopDemo, renderTable methods. Handles sorting and button state.</done>
</task>

<task type="auto">
  <name>Task 3: Integrate ModelManager with app.js and handle demo status</name>
  <files>src/web/static/app.js</files>
  <action>
Update src/web/static/app.js to integrate ModelManager:

1. Add modelManager to global state at top:
```javascript
let modelManager = null;
```

2. In DOMContentLoaded handler, after connectWebSocket(), add:
```javascript
// Note: ModelManager is created after WebSocket connects
// See handleConnectionStatus for initialization
```

3. In handleConnectionStatus function, when status is 'connected', add:
```javascript
case 'connected':
    statusText.textContent = currentStatus.charAt(0).toUpperCase() + currentStatus.slice(1);
    // Request current status from server
    wsClient.send({ command: 'status' });
    // Initialize ModelManager if not already done
    if (!modelManager && wsClient) {
        modelManager = new ModelManager(wsClient);
    } else if (modelManager) {
        modelManager.loadModels();  // Refresh on reconnect
    }
    break;
```

4. In handleMessage function, update the status case to handle demo:
```javascript
case 'status':
    // Training status changed
    if (data.status) {
        updateTrainingStatus(data.status);
        // Notify ModelManager of status changes
        if (modelManager) {
            modelManager.handleStatus(data);
        }
    }
    // ... rest of existing status handling ...
```

5. In updateTrainingStatus function, add handling for demo_running:
```javascript
case 'demo_running':
    btnStart.disabled = true;  // Can't start training during demo
    btnPause.disabled = true;
    btnStop.disabled = false;  // Stop button works for demo too
    modeToggle.disabled = true;  // Mode toggle not applicable in demo
    speedSlider.disabled = false;  // Speed works in demo
    break;
```

6. Update btnStop click handler to also stop demo:
In the existing stop button handler, the existing code sends 'stop' command which will work, but also handle demo stop explicitly by also sending demo_stop if in demo mode:
```javascript
btnStop.addEventListener('click', () => {
    // Send stop for both training and demo
    const sent = wsClient.send({ command: 'stop' });
    // Also send demo_stop in case it's a demo
    if (modelManager && modelManager.currentDemo) {
        wsClient.send({ command: 'demo_stop' });
    }

    if (sent) {
        console.log('Stop command sent');
        updateTrainingStatus('stopping');
    } else {
        console.error('Failed to send stop command - not connected');
    }
});
```

7. Export modelManager in window.app for debugging:
```javascript
window.app = {
    gameBoard: () => gameBoard,
    metricsChart: () => metricsChart,
    wsClient: () => wsClient,
    status: () => currentStatus,
    modelManager: () => modelManager,
};
```
  </action>
  <verify>
```bash
grep -c "ModelManager" src/web/static/app.js
grep -c "demo_running" src/web/static/app.js
```
Both should return 1 or more.
  </verify>
  <done>app.js creates ModelManager on WebSocket connect, passes status updates to ModelManager, handles demo_running status in UI, stop button works for both training and demo.</done>
</task>

</tasks>

<verification>
1. Model management section visible in dashboard
2. Model table shows all saved slots from /api/models
3. Save button prompts for name and saves to slot
4. Delete button confirms and removes slot
5. Export button triggers server-side export
6. Demo button starts demo mode (board updates visible)
7. Stop button stops demo mode
8. Speed slider works during demo
9. UI disables training controls during demo
</verification>

<success_criteria>
- Leaderboard table displays all saved model slots
- Table is sortable by name, lines, timesteps
- Save/Delete/Export operations work via REST API
- Demo mode starts and shows model playing
- Speed control works in demo mode
- UI correctly reflects demo state
- No JavaScript errors in console
</success_criteria>

<checkpoint type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete model management UI with leaderboard, save/delete/export, and demo mode</what-built>
  <how-to-verify>
1. Start the server: `python -m uvicorn src.web.server:app --reload`
2. Open browser to http://localhost:8000
3. If you have a saved model (from previous training):
   - Model should appear in the "Saved Models" table
   - Click "Demo" to watch the model play
   - Adjust speed slider during demo
   - Click "Stop" to end demo
4. If no models exist yet:
   - Run a short training session
   - Click "Save Current Model", enter a name
   - Model should appear in table
   - Test Demo, Export, Delete buttons
5. Verify:
   - Table sorting works (click column headers)
   - Delete confirms before removing
   - Demo disables training controls
  </how-to-verify>
  <resume-signal>Type "approved" to confirm Phase 5 complete, or describe any issues</resume-signal>
</checkpoint>

<output>
After completion, create `.planning/phases/05-model-management-polish/05-03-SUMMARY.md`
</output>
