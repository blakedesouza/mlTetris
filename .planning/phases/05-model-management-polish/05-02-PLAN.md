---
phase: 05-model-management-polish
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - src/web/training_manager.py
autonomous: true

must_haves:
  truths:
    - "Demo mode can be started with a model path"
    - "Demo mode runs inference without training (deterministic=True)"
    - "Demo mode sends board state via metrics_queue"
    - "Demo mode can be stopped with stop_demo()"
    - "Demo mode respects speed control commands"
    - "Training cannot start while demo is running"
    - "Demo cannot start while training is running"
  artifacts:
    - path: "src/web/training_manager.py"
      provides: "Demo mode worker and TrainingManager demo methods"
      contains: "_demo_worker"
  key_links:
    - from: "src/web/training_manager.py"
      to: "stable_baselines3.DQN"
      via: "DQN.load() for inference"
      pattern: "DQN\\.load\\("
    - from: "src/web/training_manager.py"
      to: "metrics_queue"
      via: "Queue for board/status messages"
      pattern: "metrics_queue\\.put\\("
---

<objective>
Implement demo mode worker function for showcasing trained models without training.

Purpose: Allow users to watch saved models play Tetris in demo mode - inference only, no learning.
Output: _demo_worker function and start_demo/stop_demo methods in TrainingManager.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-model-management-polish/05-RESEARCH.md
@.planning/phases/05-model-management-polish/05-01-SUMMARY.md

# Existing infrastructure
@src/web/training_manager.py
@src/training/callbacks.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create demo worker function</name>
  <files>src/web/training_manager.py</files>
  <action>
Add _demo_worker static method to TrainingManager class in src/web/training_manager.py.

The demo worker is similar to _training_worker but:
- Only runs inference (no learning)
- Uses deterministic=True for consistent behavior
- Sends board state and episode metrics via queue
- Handles speed commands but no pause (demo is always visual)

Add this static method after _training_worker:

```python
@staticmethod
def _demo_worker(
    model_path: str,
    metrics_queue: Queue,
    command_queue: Queue,
    stop_event: "EventType",
) -> None:
    """Worker function for demo mode - inference only, no training.

    Runs the model in evaluation mode, sending board state for visualization.
    Handles speed commands but not pause (demo is always visual).

    Args:
        model_path: Path to model.zip file to load.
        metrics_queue: Queue to send metrics/board to server.
        command_queue: Queue to receive commands from server.
        stop_event: Event for stop signal.
    """
    import time

    try:
        from src.environment import make_env, EnvConfig
        from stable_baselines3 import DQN
        import numpy as np

        # Create environment (headless - we extract board state manually)
        env_config = EnvConfig(render_mode=None)
        env = make_env(env_config)()

        # Load model for inference (no TetrisAgent needed)
        model = DQN.load(model_path, env=env)
        model.set_training_mode(False)

        metrics_queue.put({"type": "status", "status": "demo_running"})

        obs, _ = env.reset()
        episode = 0
        episode_reward = 0.0
        episode_lines = 0
        step_delay = 0.1  # Default demo speed (fairly slow for watching)
        steps_in_episode = 0

        while not stop_event.is_set():
            # Check for speed commands
            try:
                while not command_queue.empty():
                    cmd = command_queue.get_nowait()
                    if cmd.get("command") == "set_speed":
                        speed = cmd.get("speed", 1.0)
                        # Convert speed (0.1-1.0) to delay (0.5s - 0s)
                        step_delay = (1.0 - speed) * 0.5
            except Exception:
                pass

            # Predict action deterministically (no exploration)
            action, _ = model.predict(obs, deterministic=True)
            obs, reward, terminated, truncated, info = env.step(action)

            episode_reward += float(reward)
            steps_in_episode += 1

            # Track lines cleared
            lines = info.get("lines", info.get("lines_cleared", 0))
            if lines > episode_lines:
                episode_lines = lines

            # Extract and send board state
            # Navigate through wrappers to get board
            try:
                unwrapped = env.unwrapped
                if hasattr(unwrapped, 'board'):
                    # Extract playable area (20 rows, 10 cols)
                    board = unwrapped.board[0:20, 4:-4]
                    metrics_queue.put({
                        "type": "board",
                        "board": board.tolist(),
                    })
            except Exception:
                pass  # Skip board update on error

            # Send periodic metrics
            if steps_in_episode % 10 == 0:
                metrics_queue.put({
                    "type": "metrics",
                    "episode_count": episode,
                    "current_score": episode_reward,
                    "lines_cleared": episode_lines,
                })

            if terminated or truncated:
                episode += 1
                metrics_queue.put({
                    "type": "episode",
                    "episode": episode,
                    "reward": episode_reward,
                    "lines": episode_lines,
                })
                # Reset for next episode
                obs, _ = env.reset()
                episode_reward = 0.0
                episode_lines = 0
                steps_in_episode = 0

            # Delay for visualization
            if step_delay > 0:
                time.sleep(step_delay)

        metrics_queue.put({"type": "status", "status": "stopped"})

    except Exception as e:
        import traceback
        metrics_queue.put({
            "type": "error",
            "error": str(e),
            "traceback": traceback.format_exc(),
        })
        metrics_queue.put({"type": "status", "status": "stopped"})
```
  </action>
  <verify>
```bash
python -c "from src.web.training_manager import TrainingManager; print('_demo_worker' in dir(TrainingManager))"
```
  </verify>
  <done>_demo_worker static method exists in TrainingManager with inference loop, board extraction, speed control, and proper stop handling.</done>
</task>

<task type="auto">
  <name>Task 2: Add start_demo and stop_demo methods to TrainingManager</name>
  <files>src/web/training_manager.py</files>
  <action>
Add demo mode management methods to TrainingManager class.

1. Add demo_process attribute in __init__:
```python
def __init__(self):
    # ...existing code...
    self.demo_process: Optional[Process] = None
```

2. Add start_demo method:
```python
def start_demo(self, model_path: str) -> bool:
    """Start demo mode with specified model.

    Args:
        model_path: Path to model.zip file to load.

    Returns:
        True if demo started, False if training/demo already running.
    """
    # Prevent demo if training is running
    if self.is_running():
        return False
    # Prevent if demo already running
    if self.is_demo_running():
        return False

    # Clear queues before starting
    self._clear_queue(self.metrics_queue)
    self._clear_queue(self.command_queue)

    # Reset stop event
    self.stop_event.clear()

    # Start demo process
    self.demo_process = Process(
        target=self._demo_worker,
        args=(
            model_path,
            self.metrics_queue,
            self.command_queue,
            self.stop_event,
        ),
        daemon=True,
    )
    self.demo_process.start()
    self.status = "demo_running"
    self.visual_mode = True  # Demo is always visual
    return True
```

3. Add stop_demo method:
```python
def stop_demo(self) -> None:
    """Stop the demo process."""
    if not self.is_demo_running():
        return

    self.status = "stopping"
    self.stop_event.set()
    self.demo_process.join(timeout=3)

    if self.demo_process.is_alive():
        self.demo_process.terminate()
        self.demo_process.join(timeout=1)

    self.demo_process = None
    self.status = "stopped"
```

4. Add is_demo_running method:
```python
def is_demo_running(self) -> bool:
    """Check if demo process is alive.

    Returns:
        True if demo process is running, False otherwise.
    """
    return self.demo_process is not None and self.demo_process.is_alive()
```

5. Update get_status to include demo state:
```python
def get_status(self) -> Dict[str, Any]:
    """Get current training/demo status."""
    return {
        "status": self.status,
        "is_running": self.is_running(),
        "is_demo": self.is_demo_running(),
        "visual_mode": self.visual_mode,
        "speed": self.speed,
    }
```

6. Update stop_training to also stop demo if needed (defensive):
At the start of stop_training():
```python
def stop_training(self) -> None:
    """Stop the training process (or demo if running)."""
    # Also stop demo if running
    if self.is_demo_running():
        self.stop_demo()
        return
    # ...rest of existing code...
```
  </action>
  <verify>
```bash
python -c "
from src.web.training_manager import TrainingManager
tm = TrainingManager()
print('start_demo:', hasattr(tm, 'start_demo'))
print('stop_demo:', hasattr(tm, 'stop_demo'))
print('is_demo_running:', hasattr(tm, 'is_demo_running'))
status = tm.get_status()
print('is_demo in status:', 'is_demo' in status)
"
```
  </verify>
  <done>TrainingManager has start_demo(), stop_demo(), is_demo_running() methods. get_status() includes is_demo field. Demo and training cannot run simultaneously.</done>
</task>

</tasks>

<verification>
1. _demo_worker function loads model with DQN.load() and runs inference loop
2. Demo worker sends board state via metrics_queue
3. Demo worker handles speed commands
4. Demo worker responds to stop_event
5. start_demo returns False if training is already running
6. start_demo returns False if demo is already running
7. stop_demo terminates demo process cleanly
8. get_status includes is_demo field
</verification>

<success_criteria>
- Demo mode runs inference with deterministic=True (no training)
- Board state sent via existing metrics_queue infrastructure
- Speed slider works in demo mode
- Demo cannot start while training is running (and vice versa)
- Demo process terminates cleanly on stop
- Status correctly reports demo_running state
</success_criteria>

<output>
After completion, create `.planning/phases/05-model-management-polish/05-02-SUMMARY.md`
</output>
