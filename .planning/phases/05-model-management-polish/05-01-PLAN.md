---
phase: 05-model-management-polish
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/training/model_slots.py
  - src/training/__init__.py
  - src/web/server.py
autonomous: true

must_haves:
  truths:
    - "ModelSlotManager can list all saved model slots with metadata"
    - "ModelSlotManager can copy model from best/latest to named slot"
    - "ModelSlotManager can delete a named slot"
    - "ModelSlotManager can export model.zip to standalone file"
    - "REST API returns list of models at GET /api/models"
    - "REST API saves model to slot at POST /api/models/save"
    - "REST API deletes slot at DELETE /api/models/{name}"
    - "REST API exports model at POST /api/models/export"
  artifacts:
    - path: "src/training/model_slots.py"
      provides: "ModelSlotManager class with CRUD and export"
      exports: ["ModelSlotManager"]
    - path: "src/web/server.py"
      provides: "REST endpoints for model management"
      contains: "/api/models"
  key_links:
    - from: "src/web/server.py"
      to: "src/training/model_slots.py"
      via: "ModelSlotManager import and instantiation"
      pattern: "from src.training.model_slots import ModelSlotManager"
---

<objective>
Create backend infrastructure for model slot management including the ModelSlotManager class and REST API endpoints.

Purpose: Enable storing multiple model versions in named slots and expose operations via HTTP for frontend consumption.
Output: ModelSlotManager class with CRUD operations, REST endpoints for model listing/saving/deleting/exporting.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-model-management-polish/05-RESEARCH.md

# Existing infrastructure
@src/training/agent.py
@src/web/server.py
@src/web/training_manager.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ModelSlotManager class</name>
  <files>src/training/model_slots.py, src/training/__init__.py</files>
  <action>
Create src/training/model_slots.py with ModelSlotManager class:

```python
from pathlib import Path
import json
import shutil
from typing import List, Dict, Optional

class ModelSlotManager:
    """Manages named model slots under checkpoints/slots/."""

    def __init__(self, base_dir: str = "./checkpoints"):
        self.base_dir = Path(base_dir)
        self.slots_dir = self.base_dir / "slots"
        self.slots_dir.mkdir(parents=True, exist_ok=True)

    def list_slots(self) -> List[Dict]:
        """List all model slots with metadata.

        Returns list of dicts with: name, path, and metadata fields
        (total_timesteps_trained, num_timesteps, config, best_lines if available)
        """
        # Iterate slots_dir, read metadata.json from each

    def save_to_slot(self, source: str, slot_name: str) -> bool:
        """Copy model from source (best/latest/final) to named slot.

        Only copies model.zip and metadata.json (NOT replay_buffer.pkl - too large).
        Overwrites if slot exists.
        Returns True on success, False if source doesn't exist.
        """

    def delete_slot(self, slot_name: str) -> bool:
        """Delete a named slot. Returns True if deleted, False if not found."""

    def export_model(self, slot_name: str, export_path: str) -> bool:
        """Export model.zip to standalone file path.

        Returns True on success, False if slot doesn't exist.
        """

    def get_slot_path(self, slot_name: str) -> Optional[Path]:
        """Get path to slot directory, or None if doesn't exist."""

    def slot_exists(self, slot_name: str) -> bool:
        """Check if a slot with given name exists."""
```

Key implementation details:
- list_slots: Filter to directories containing model.zip, load metadata.json
- save_to_slot: Use shutil.copytree with dirs_exist_ok=True for overwrite
- delete_slot: Use shutil.rmtree
- export_model: Use shutil.copy2 to preserve timestamps
- Validate slot names (alphanumeric, underscore, hyphen only)

Update src/training/__init__.py to export ModelSlotManager:
```python
from .model_slots import ModelSlotManager
```
  </action>
  <verify>
```bash
python -c "from src.training import ModelSlotManager; m = ModelSlotManager(); print('ModelSlotManager created:', m.slots_dir)"
```
  </verify>
  <done>ModelSlotManager class exists with list_slots, save_to_slot, delete_slot, export_model, get_slot_path methods. Import works from src.training.</done>
</task>

<task type="auto">
  <name>Task 2: Add REST API endpoints for model management</name>
  <files>src/web/server.py</files>
  <action>
Add model management REST endpoints to src/web/server.py:

1. Import ModelSlotManager at top:
```python
from src.training.model_slots import ModelSlotManager
```

2. Create module-level instance (after training_manager):
```python
model_manager = ModelSlotManager()
```

3. Add Pydantic models for requests:
```python
class SaveSlotRequest(BaseModel):
    """Request body for saving model to slot."""
    source: str = "best"  # "best", "latest", or "final"
    slot_name: str

class ExportRequest(BaseModel):
    """Request body for exporting model."""
    slot_name: str
    filename: str  # Just the filename, will be saved to exports/
```

4. Add REST endpoints:

```python
@app.get("/api/models")
async def list_models():
    """List all saved model slots with metadata."""
    return model_manager.list_slots()

@app.post("/api/models/save")
async def save_model(request: SaveSlotRequest):
    """Save current model to named slot."""
    # Validate source is one of best/latest/final
    if request.source not in ("best", "latest", "final"):
        return JSONResponse(
            status_code=400,
            content={"success": False, "error": "Invalid source. Use: best, latest, final"}
        )
    success = model_manager.save_to_slot(request.source, request.slot_name)
    if success:
        return {"success": True, "message": f"Model saved to slot '{request.slot_name}'"}
    return JSONResponse(
        status_code=404,
        content={"success": False, "error": f"Source '{request.source}' not found"}
    )

@app.delete("/api/models/{slot_name}")
async def delete_model(slot_name: str):
    """Delete a saved model slot."""
    success = model_manager.delete_slot(slot_name)
    if success:
        return {"success": True, "message": f"Slot '{slot_name}' deleted"}
    return JSONResponse(
        status_code=404,
        content={"success": False, "error": f"Slot '{slot_name}' not found"}
    )

@app.post("/api/models/export")
async def export_model(request: ExportRequest):
    """Export model to standalone file for download."""
    import asyncio
    from concurrent.futures import ThreadPoolExecutor

    # Create exports directory
    exports_dir = Path("./exports")
    exports_dir.mkdir(exist_ok=True)
    export_path = exports_dir / request.filename

    # Run in thread pool to avoid blocking
    loop = asyncio.get_event_loop()
    executor = ThreadPoolExecutor(max_workers=1)
    success = await loop.run_in_executor(
        executor,
        model_manager.export_model,
        request.slot_name,
        str(export_path)
    )

    if success:
        return {"success": True, "path": str(export_path), "message": f"Model exported to {export_path}"}
    return JSONResponse(
        status_code=404,
        content={"success": False, "error": f"Slot '{request.slot_name}' not found"}
    )
```
  </action>
  <verify>
```bash
# Start server and test endpoints
cd "C:\Users\Blake\PycharmProjects\mlTetris"
timeout 5 python -m uvicorn src.web.server:app --host 127.0.0.1 --port 8765 &
sleep 2
curl -s http://127.0.0.1:8765/api/models
curl -s -X POST http://127.0.0.1:8765/api/models/save -H "Content-Type: application/json" -d '{"source": "best", "slot_name": "test_slot"}'
```
Note: May return empty list or 404 if no models exist yet - that's expected.
  </verify>
  <done>REST endpoints exist: GET /api/models returns slot list, POST /api/models/save saves to slot, DELETE /api/models/{name} deletes slot, POST /api/models/export exports model.zip.</done>
</task>

<task type="auto">
  <name>Task 3: Add demo mode endpoints and WebSocket commands</name>
  <files>src/web/server.py</files>
  <action>
Add demo mode REST endpoints and WebSocket command handlers to src/web/server.py:

1. Add REST endpoints for demo mode:

```python
@app.post("/api/demo/start/{slot_name}")
async def start_demo(slot_name: str):
    """Start demo mode with specified model."""
    if not model_manager.slot_exists(slot_name):
        return JSONResponse(
            status_code=404,
            content={"success": False, "error": f"Slot '{slot_name}' not found"}
        )

    model_path = model_manager.get_slot_path(slot_name) / "model.zip"
    success = training_manager.start_demo(str(model_path))

    if success:
        return {"success": True, "message": f"Demo started for '{slot_name}'"}
    return JSONResponse(
        status_code=409,
        content={"success": False, "error": "Training or demo already running"}
    )

@app.post("/api/demo/stop")
async def stop_demo():
    """Stop demo mode."""
    training_manager.stop_demo()
    return {"success": True, "message": "Demo stopped"}
```

2. Add WebSocket command handlers in websocket_endpoint() function.
In the command handling section, add cases for demo commands:

```python
elif command == "demo_start":
    slot_name = data.get("slot_name")
    if not slot_name:
        await connection_manager.send_to(
            websocket,
            {"type": "error", "error": "Missing slot_name for demo_start"}
        )
    elif not model_manager.slot_exists(slot_name):
        await connection_manager.send_to(
            websocket,
            {"type": "error", "error": f"Slot '{slot_name}' not found"}
        )
    else:
        model_path = model_manager.get_slot_path(slot_name) / "model.zip"
        success = training_manager.start_demo(str(model_path))
        if success:
            await connection_manager.send_to(
                websocket,
                {"type": "status", "status": "demo_running", "message": f"Demo started: {slot_name}"}
            )
        else:
            await connection_manager.send_to(
                websocket,
                {"type": "error", "error": "Training or demo already running"}
            )

elif command == "demo_stop":
    training_manager.stop_demo()
    await connection_manager.send_to(
        websocket,
        {"type": "status", "status": "stopped", "message": "Demo stopped"}
    )
```

3. Update the docstring for websocket_endpoint to document new commands:
```python
Commands:
    ...existing commands...
    - {"command": "demo_start", "slot_name": "..."}: Start demo mode with model from slot
    - {"command": "demo_stop"}: Stop demo mode
```
  </action>
  <verify>
```bash
# Verify endpoints are defined (syntax check)
python -c "from src.web.server import app; routes = [r.path for r in app.routes]; print('/api/demo/start/{slot_name}' in str(routes) or 'demo' in str(routes))"
```
  </verify>
  <done>Demo mode endpoints exist: POST /api/demo/start/{slot_name}, POST /api/demo/stop. WebSocket accepts demo_start and demo_stop commands.</done>
</task>

</tasks>

<verification>
1. ModelSlotManager class exists and can be imported
2. REST endpoints respond correctly:
   - GET /api/models returns array (empty if no slots)
   - POST /api/models/save with valid source returns success or 404
   - DELETE /api/models/{name} returns success or 404
   - POST /api/models/export returns success or 404
3. Demo endpoints exist (implementation in Plan 05-02)
</verification>

<success_criteria>
- ModelSlotManager class complete with CRUD + export methods
- All REST endpoints return appropriate responses
- WebSocket command handlers added for demo_start/demo_stop
- Code follows existing project patterns (Pydantic, JSONResponse for errors)
- No new dependencies added
</success_criteria>

<output>
After completion, create `.planning/phases/05-model-management-polish/05-01-SUMMARY.md`
</output>
