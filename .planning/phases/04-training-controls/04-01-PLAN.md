---
phase: 04-training-controls
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/web/training_manager.py
  - src/training/callbacks.py
  - src/training/__init__.py
autonomous: true
user_setup: []

must_haves:
  truths:
    - "TrainingManager has pause_event and stop_event as multiprocessing.Event objects"
    - "Callback blocks on pause_event.wait() when training is paused"
    - "Callback respects visual_mode flag to control board update frequency"
    - "Callback auto-saves best model when new high score achieved"
    - "Speed control via step_delay affects visualization without slowing training in headless mode"
  artifacts:
    - path: "src/web/training_manager.py"
      provides: "pause_training(), resume_training(), set_mode(), set_speed() methods"
      contains: "multiprocessing.Event"
    - path: "src/training/callbacks.py"
      provides: "Enhanced WebMetricsCallback with pause/visual/speed/best-save"
      contains: "pause_event.wait()"
  key_links:
    - from: "src/web/training_manager.py"
      to: "src/training/callbacks.py"
      via: "Event objects passed to _training_worker"
      pattern: "pause_event.*stop_event"
---

<objective>
Add Event-based pause/resume, visual mode toggle, speed control, and auto-save best model to the backend training infrastructure.

Purpose: Enable fine-grained training control (TRAIN-09, TRAIN-10, TRAIN-11, TRAIN-12, MODEL-07) at the process communication layer.
Output: Enhanced TrainingManager with Event synchronization and WebMetricsCallback with all control features.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-training-controls/04-RESEARCH.md

# Current implementation to enhance
@src/web/training_manager.py
@src/training/callbacks.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Event objects to TrainingManager</name>
  <files>src/web/training_manager.py</files>
  <action>
Enhance TrainingManager to use multiprocessing.Event for pause/resume and stop control:

1. Import Event from multiprocessing (add to existing import)

2. In __init__():
   - Add `self.pause_event = Event()`
   - Add `self.stop_event = Event()`
   - Initialize: `self.pause_event.set()` (not paused - set = unblocked)
   - Initialize: `self.stop_event.clear()` (not stopped)

3. Modify start_training():
   - Before spawning process: `self.pause_event.set()` and `self.stop_event.clear()` to reset state
   - Pass `self.pause_event, self.stop_event` as additional args to Process target
   - Update _training_worker signature to accept these Events

4. Modify stop_training():
   - Call `self.stop_event.set()` to signal stop
   - Call `self.pause_event.set()` to unblock if paused (so worker can exit)
   - Keep existing join/terminate logic

5. Add pause_training() method:
   ```python
   def pause_training(self) -> bool:
       if not self.is_running() or self.status == "paused":
           return False
       self.pause_event.clear()  # Block wait()
       self.status = "paused"
       return True
   ```

6. Add resume_training() method:
   ```python
   def resume_training(self) -> bool:
       if self.status != "paused":
           return False
       self.pause_event.set()  # Unblock wait()
       self.status = "running"
       return True
   ```

7. Add set_mode() method:
   ```python
   def set_mode(self, visual: bool) -> None:
       self.command_queue.put({"command": "set_mode", "visual": visual})
   ```

8. Add set_speed() method:
   ```python
   def set_speed(self, speed: float) -> None:
       self.command_queue.put({"command": "set_speed", "speed": speed})
   ```

9. Update get_status() to include visual_mode info (optional, can add later)

10. Update _training_worker signature and pass Events to WebMetricsCallback:
    ```python
    @staticmethod
    def _training_worker(
        config_dict: Dict[str, Any],
        metrics_queue: Queue,
        command_queue: Queue,
        pause_event: Event,
        stop_event: Event,
    ) -> None:
    ```

    Update WebMetricsCallback instantiation to pass pause_event and stop_event.

Note: The command_queue "stop" command is now supplemented by stop_event for faster response.
  </action>
  <verify>
Run: `python -c "from src.web.training_manager import TrainingManager; tm = TrainingManager(); print('pause_event:', tm.pause_event.is_set(), 'stop_event:', tm.stop_event.is_set())"`
Expected: `pause_event: True stop_event: False`
  </verify>
  <done>
TrainingManager has Event objects, pause/resume/set_mode/set_speed methods, and passes Events to worker.
  </done>
</task>

<task type="auto">
  <name>Task 2: Enhance WebMetricsCallback with controls</name>
  <files>src/training/callbacks.py, src/training/__init__.py</files>
  <action>
Enhance WebMetricsCallback to support pause/resume, visual mode, speed control, and auto-save best model:

1. Update imports:
   ```python
   import time
   import json
   from multiprocessing import Queue, Event
   from pathlib import Path
   ```

2. Update __init__ signature:
   ```python
   def __init__(
       self,
       metrics_queue: Queue,
       command_queue: Queue,
       pause_event: Optional[Event] = None,
       stop_event: Optional[Event] = None,
       checkpoint_dir: str = "./checkpoints",
       update_freq: int = 100,
       board_update_freq: int = 50,
       verbose: int = 0,
   ):
   ```

   Add new instance variables:
   ```python
   self.pause_event = pause_event
   self.stop_event = stop_event
   self.checkpoint_dir = Path(checkpoint_dir)
   self.visual_mode = False  # Start in headless mode
   self.step_delay = 0.0  # Seconds between steps in visual mode
   ```

3. Rewrite _on_step() with correct order (from 04-RESEARCH.md):
   ```python
   def _on_step(self) -> bool:
       # 1. Check for stop FIRST (fast path via Event)
       if self.stop_event is not None and self.stop_event.is_set():
           return False

       # 2. Process commands BEFORE pause check (so resume works)
       self._process_commands()

       # 3. Block if paused (wait returns immediately if event is set)
       if self.pause_event is not None:
           self.pause_event.wait()

       # 4. After unpausing, check stop again (might have been set while paused)
       if self.stop_event is not None and self.stop_event.is_set():
           return False

       # 5. Track reward (existing logic)
       rewards = self.locals.get("rewards", [0])
       self.current_episode_reward += rewards[0] if rewards else 0

       # 6. Track lines from info (existing logic)
       infos = self.locals.get("infos", [{}])
       for info in infos:
           lines = info.get("lines", info.get("lines_cleared", 0))
           if lines > self.current_episode_lines:
               self.current_episode_lines = lines

       # 7. Send board state if in visual mode
       if self.visual_mode and self.n_calls % self.board_update_freq == 0:
           self._send_board_state()
           if self.step_delay > 0:
               time.sleep(self.step_delay)

       # 8. Send metrics periodically (regardless of mode)
       if self.n_calls % self.update_freq == 0:
           self._send_metrics()

       # 9. Check for episode end
       dones = self.locals.get("dones", [False])
       if dones[0]:
           self._on_episode_end()

       return True
   ```

4. Add _process_commands() method:
   ```python
   def _process_commands(self) -> None:
       """Process pending commands from web server."""
       try:
           while not self.command_queue.empty():
               cmd = self.command_queue.get_nowait()
               command = cmd.get("command")

               if command == "stop":
                   if self.stop_event is not None:
                       self.stop_event.set()
               elif command == "set_mode":
                   self.visual_mode = cmd.get("visual", False)
                   self.metrics_queue.put({
                       "type": "info",
                       "message": f"Mode: {'visual' if self.visual_mode else 'headless'}"
                   })
               elif command == "set_speed":
                   # Speed 1.0 = no delay, 0.1 = max delay (100ms between steps)
                   speed = max(0.1, min(1.0, cmd.get("speed", 1.0)))
                   self.step_delay = (1.0 - speed) * 0.1
       except Exception:
           pass
   ```

5. Enhance _on_episode_end() to auto-save best model:
   ```python
   def _on_episode_end(self) -> None:
       """Handle episode completion and auto-save best model."""
       self.episode_count += 1
       self.episode_rewards.append(self.current_episode_reward)
       self.episode_lines.append(self.current_episode_lines)

       # Check for new best and auto-save (MODEL-07)
       if self.current_episode_lines > self.best_lines:
           old_best = self.best_lines
           self.best_lines = self.current_episode_lines
           self._save_best_model()

       # Send episode completion data (convert numpy types for JSON)
       self.metrics_queue.put({
           "type": "episode",
           "episode": int(self.episode_count),
           "reward": float(self.current_episode_reward),
           "lines": int(self.current_episode_lines),
       })

       # Reset for next episode
       self.current_episode_reward = 0
       self.current_episode_lines = 0
   ```

6. Add _save_best_model() method:
   ```python
   def _save_best_model(self) -> None:
       """Save best model checkpoint when new high score achieved."""
       try:
           best_path = self.checkpoint_dir / "best"
           best_path.mkdir(parents=True, exist_ok=True)

           # Save model
           self.model.save(best_path / "model.zip")

           # Save metadata
           metadata = {
               "best_lines": int(self.best_lines),
               "episode": int(self.episode_count),
               "timesteps": int(self.num_timesteps),
           }
           with open(best_path / "metadata.json", "w") as f:
               json.dump(metadata, f, indent=2)

           self.metrics_queue.put({
               "type": "info",
               "message": f"New best: {self.best_lines} lines - saved to {best_path}"
           })
       except Exception as e:
           if self.verbose > 0:
               print(f"Error saving best model: {e}")
   ```

Note: The old stop command logic in _on_step is now handled by stop_event for faster response, but _process_commands still handles it for backward compatibility.
  </action>
  <verify>
Run: `python -c "from src.training.callbacks import WebMetricsCallback; from multiprocessing import Queue, Event; cb = WebMetricsCallback(Queue(), Queue(), Event(), Event()); print('visual_mode:', cb.visual_mode, 'step_delay:', cb.step_delay)"`
Expected: `visual_mode: False step_delay: 0.0`

Run: `python -m pytest tests/ -v --tb=short -x` to ensure existing tests still pass.
  </verify>
  <done>
WebMetricsCallback supports Event-based pause, visual mode toggle, speed control, and auto-save best model.
  </done>
</task>

</tasks>

<verification>
After both tasks:
1. `python -c "from src.web.training_manager import TrainingManager; tm = TrainingManager(); print('Events:', tm.pause_event, tm.stop_event)"`
2. `python -c "from src.training.callbacks import WebMetricsCallback; from multiprocessing import Queue, Event; cb = WebMetricsCallback(Queue(), Queue(), Event(), Event(), checkpoint_dir='./test_checkpoints'); print('OK')"`
3. `python -m pytest tests/ -v --tb=short` - all tests pass
</verification>

<success_criteria>
- TrainingManager has pause_event and stop_event as Event objects
- TrainingManager has pause_training(), resume_training(), set_mode(), set_speed() methods
- WebMetricsCallback accepts pause_event and stop_event in constructor
- WebMetricsCallback blocks on pause_event.wait() when paused
- WebMetricsCallback respects visual_mode to control board updates
- WebMetricsCallback auto-saves best model on new high score
- All existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/04-training-controls/04-01-SUMMARY.md`
</output>
