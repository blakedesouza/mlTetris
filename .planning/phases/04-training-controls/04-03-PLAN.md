---
phase: 04-training-controls
plan: 03
type: execute
wave: 3
depends_on: ["04-01", "04-02"]
files_modified:
  - src/web/static/app.js
autonomous: false

must_haves:
  truths:
    - "Pause button toggles between Pause and Resume based on training state"
    - "Mode toggle sends set_mode command and enables/disables speed slider"
    - "Speed slider sends set_speed command when adjusted"
    - "UI state updates correctly when paused/resumed"
    - "All controls are enabled/disabled appropriately based on training state"
  artifacts:
    - path: "src/web/static/app.js"
      provides: "Event handlers for pause, mode toggle, speed slider"
      contains: "btn-pause"
  key_links:
    - from: "src/web/static/app.js"
      to: "WebSocket"
      via: "wsClient.send({ command: 'pause' })"
      pattern: "command.*pause|resume|set_mode|set_speed"
---

<objective>
Wire the frontend UI controls to WebSocket commands and verify end-to-end training control functionality.

Purpose: Complete the frontend-to-backend control path and verify all training controls work correctly.
Output: Fully functional training controls (pause/resume, mode toggle, speed slider) with end-to-end verification.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-training-controls/04-01-SUMMARY.md
@.planning/phases/04-training-controls/04-02-SUMMARY.md

# File to modify
@src/web/static/app.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire control UI elements to WebSocket commands</name>
  <files>src/web/static/app.js</files>
  <action>
Update app.js to handle the new control elements:

1. Update setupControls() function to include pause, mode, and speed handlers:

```javascript
function setupControls() {
    const btnStart = document.getElementById('btn-start');
    const btnPause = document.getElementById('btn-pause');
    const btnStop = document.getElementById('btn-stop');
    const modeToggle = document.getElementById('mode-toggle');
    const speedSlider = document.getElementById('speed-slider');
    const speedValue = document.getElementById('speed-value');

    // Start button (existing logic)
    btnStart.addEventListener('click', () => {
        const targetLines = parseInt(document.getElementById('target-lines').value) || null;
        const maxTimesteps = parseInt(document.getElementById('max-timesteps').value) || 100000;

        const sent = wsClient.send({
            command: 'start',
            config: {
                target_lines: targetLines,
                max_timesteps: maxTimesteps,
            }
        });

        if (sent) {
            console.log('Start command sent');
            updateTrainingStatus('running');
            metricsChart.clear();
        } else {
            console.error('Failed to send start command - not connected');
        }
    });

    // Pause/Resume button - toggles based on state
    btnPause.addEventListener('click', () => {
        if (currentStatus === 'running') {
            const sent = wsClient.send({ command: 'pause' });
            if (sent) {
                console.log('Pause command sent');
            }
        } else if (currentStatus === 'paused') {
            const sent = wsClient.send({ command: 'resume' });
            if (sent) {
                console.log('Resume command sent');
            }
        }
    });

    // Stop button (existing logic)
    btnStop.addEventListener('click', () => {
        const sent = wsClient.send({ command: 'stop' });
        if (sent) {
            console.log('Stop command sent');
            updateTrainingStatus('stopping');
        } else {
            console.error('Failed to send stop command - not connected');
        }
    });

    // Mode toggle - headless vs visual
    modeToggle.addEventListener('change', (e) => {
        const visual = e.target.checked;
        wsClient.send({
            command: 'set_mode',
            visual: visual
        });
        console.log(`Mode set to: ${visual ? 'visual' : 'headless'}`);

        // Enable/disable speed slider based on mode
        speedSlider.disabled = !visual;
    });

    // Speed slider
    speedSlider.addEventListener('input', (e) => {
        const speed = parseFloat(e.target.value);
        speedValue.textContent = speed.toFixed(1) + 'x';
    });

    // Send speed on change (not every input for less WebSocket traffic)
    speedSlider.addEventListener('change', (e) => {
        const speed = parseFloat(e.target.value);
        wsClient.send({
            command: 'set_speed',
            speed: speed
        });
        console.log(`Speed set to: ${speed}`);
    });
}
```

2. Update updateTrainingStatus() to handle paused state and control enable/disable logic:

```javascript
function updateTrainingStatus(status) {
    currentStatus = status;

    const indicator = document.getElementById('status-indicator');
    const statusText = document.getElementById('status-text');
    const btnStart = document.getElementById('btn-start');
    const btnPause = document.getElementById('btn-pause');
    const btnStop = document.getElementById('btn-stop');
    const modeToggle = document.getElementById('mode-toggle');
    const speedSlider = document.getElementById('speed-slider');
    const configInputs = document.querySelectorAll('.config-item input');

    // Update status indicator
    indicator.className = 'status ' + status;
    statusText.textContent = status.charAt(0).toUpperCase() + status.slice(1);

    // Update button states based on status
    switch (status) {
        case 'stopped':
            btnStart.disabled = false;
            btnPause.disabled = true;
            btnPause.textContent = 'Pause';
            btnStop.disabled = true;
            modeToggle.disabled = false;
            speedSlider.disabled = true;  // Only enabled in visual mode while running
            break;

        case 'running':
            btnStart.disabled = true;
            btnPause.disabled = false;
            btnPause.textContent = 'Pause';
            btnStop.disabled = false;
            modeToggle.disabled = false;
            // Speed slider enabled only if visual mode is on
            speedSlider.disabled = !modeToggle.checked;
            break;

        case 'paused':
            btnStart.disabled = true;
            btnPause.disabled = false;
            btnPause.textContent = 'Resume';
            btnStop.disabled = false;
            modeToggle.disabled = false;
            speedSlider.disabled = !modeToggle.checked;
            break;

        case 'stopping':
            btnStart.disabled = true;
            btnPause.disabled = true;
            btnStop.disabled = true;
            modeToggle.disabled = true;
            speedSlider.disabled = true;
            break;
    }

    // Disable config inputs while training
    const isTraining = (status === 'running' || status === 'paused' || status === 'stopping');
    configInputs.forEach(input => {
        input.disabled = isTraining;
    });
}
```

3. Ensure handleMessage handles paused status properly (already handled by existing status case, but verify it works with 'paused' value).
  </action>
  <verify>
1. Verify JS syntax is valid:
   `node --check src/web/static/app.js`

2. Verify the new handlers are present:
   `findstr /C:"btn-pause" /C:"mode-toggle" /C:"speed-slider" src\web\static\app.js`
  </verify>
  <done>
All control UI elements are wired to send WebSocket commands and update UI state appropriately.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 2: End-to-end training control verification</name>
  <what-built>
Complete training control system:
- Pause/Resume: Event-based blocking in callback
- Visual Mode Toggle: Controls whether board updates are sent
- Speed Slider: Controls step delay in visual mode
- Auto-save Best: Saves model when new high score achieved
  </what-built>
  <how-to-verify>
1. Start the server:
   ```
   cd C:\Users\Blake\PycharmProjects\mlTetris
   python -m uvicorn src.web.server:app --reload
   ```

2. Open http://localhost:8000 in browser

3. Test Pause/Resume (TRAIN-10, TRAIN-11):
   - Click "Start Training" and wait for metrics to update
   - Click "Pause" button - verify:
     - Status changes to "Paused" (orange indicator with pulse)
     - Button text changes to "Resume"
     - Metrics stop updating (timesteps freeze)
     - Board freezes if in visual mode
   - Click "Resume" - verify:
     - Status changes to "Running"
     - Button text changes to "Pause"
     - Metrics resume updating

4. Test Mode Toggle (TRAIN-09):
   - While training is running, toggle "Visual (Watch)" on
   - Verify board updates start appearing
   - Toggle back to "Headless (Fast)"
   - Verify board stops updating (or updates much less frequently)
   - Training should continue uninterrupted in both cases

5. Test Speed Slider (TRAIN-12):
   - Enable Visual mode
   - Adjust speed slider while watching board
   - At 1.0x: fast updates
   - At 0.1x: slow updates (visible delay between steps)
   - Verify slider is disabled when in headless mode

6. Test Auto-save Best Model (MODEL-07):
   - Let training run until an episode completes with lines > 0
   - Watch for "New best: X lines - saved" info message
   - Verify checkpoints/best/ directory contains model.zip and metadata.json

7. Test Control State Preservation:
   - Pause training, then stop
   - Start new training - verify starts fresh (not paused)
   - Pause, stop, start - verify controls reset properly
  </how-to-verify>
  <resume-signal>
Type "approved" if all controls work correctly.
If issues found, describe what failed and expected behavior.
  </resume-signal>
</task>

</tasks>

<verification>
All requirements verified:
- TRAIN-09: Mode toggle works without interrupting training
- TRAIN-10: Pause freezes training state
- TRAIN-11: Resume continues from exact paused state
- TRAIN-12: Speed slider affects visualization speed in visual mode
- MODEL-07: Best model auto-saves on new high score
</verification>

<success_criteria>
- Pause button toggles training state and updates button text
- Resume continues training from exact paused position
- Mode toggle switches between headless and visual without restart
- Speed slider only active in visual mode, affects update rate
- Best model saves automatically to checkpoints/best/ on new high score
- All controls enabled/disabled appropriately based on training state
- Human verification confirms all features work end-to-end
</success_criteria>

<output>
After completion, create `.planning/phases/04-training-controls/04-03-SUMMARY.md`
</output>
